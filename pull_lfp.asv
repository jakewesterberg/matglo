function lfp = pull_lfp(lfp_dir, unit ss, varargin)

% Jake Westerberg
% Vanderbilt University
% jakewesterberg@gmail.com

% defaults
fs = 1000; % at or below 1000
pre_dur = 1;
on_dur = 1;
off_dur = 1;

storage_type = 'matfile';
file_path = [pwd filesep];
file_name = 'default_file_name.mat';
optimize_speed = true;

varStrInd = find(cellfun(@ischar,varargin));
for iv = 1:length(varStrInd)
    switch varargin{varStrInd(iv)}
        case {'-f','fs','sampling_frequency'}
            fs = varargin{varStrInd(iv)+1};
        case {'-pred', 'pre_dur'}
            pre_dur = varargin{varStrInd(iv)+1};
        case {'-ond', 'on_dur'}
            on_dur = varargin{varStrInd(iv)+1};
        case {'-offd', 'off_dur'}
            off_dur = varargin{varStrInd(iv)+1};
        case {'-s', 'storage_type'}
            storage_type = varargin{varStrInd(iv)+1};
        case {'-p', 'file_path'}
            file_path = varargin{varStrInd(iv)+1};
        case {'-n', 'file_name'}
            file_name = varargin{varStrInd(iv)+1};
        case {'-o', 'optimize_speed'}
            optimize_speed = varargin{varStrInd(iv)+1};
    end
end

%% Create GLO trial data
switch storage_type
    case 'matfile'

        lfp_data_length =  numel([ceil((ss.on(1)-pre_dur)*1000) : ceil((ss.on(1)+on_dur)*1000), ...
            ceil(ss.off(1)*1000) : ceil((ss.off(1)+off_dur)*1000)]);

        save([file_path file_name], 'fs', 'pre_dur', 'on_dur', 'off_dur', 'file_name', '-v7.3')
        lfp = matfile([file_path file_name], 'Writable', true);
        lfp.conv = zeros(unit_info.total, lfp_data_length, ss.total_trials, 'single');

        switch optimize_speed
            case false
                for j = 1 : unit_info.total
                    conv_data                               = zeros(1, ceil(max(unit_info.spk_times(:)) * 1000)+1000, 'single');
                    conv_data(1, ceil(unit_info.spk_times(unit_info.spk_unit == j) * 1000))   = 1;
                    conv_data                               = spks_conv(conv_data, spks_kernel('psp')) .* 1000;

                    for i = 1 : ss.total_trials
                        lfp.conv(j,1:lfp_data_length,i)   = ...
                            [conv_data(:, ceil((ss.on(i)-lfp.pre_dur)*1000) : ceil((ss.on(i)+lfp.on_dur)*1000)), ...
                            conv_data(:, ceil(ss.off(i)*1000) : ceil((ss.off(i)+lfp.off_dur)*1000))];
                    end

                end
                clear conv_data

            case true
                mem = memory;

                sson = ss.on - (min(ss.on) - pre_dur);
                ssoff = ss.off - (min(ss.on) - pre_dur);
                unit_info.spk_times = unit_info.spk_times - (min(ss.on) - pre_dur);

                onv_1 = ceil((sson-pre_dur)*1000) + 1;
                onv_2 = ceil((sson+on_dur)*1000) + 1;
                offv_1 = ceil((ssoff)*1000) + 1;
                offv_2 = ceil((ssoff+off_dur)*1000) + 1;

                tt = ss.total_trials;

                all_spktimes = unit_info.spk_times(unit_info.spk_times >= 0 & unit_info.spk_times <= max(ssoff)+off_dur);
                all_spkids = unit_info.spk_unit(unit_info.spk_times >= 0 & unit_info.spk_times <= max(ssoff)+off_dur);

                channel_slice = ceil(.33 * (mem.MemAvailableAllArrays / 4 / ceil(max(all_spktimes) * 1000)+1000));
                if channel_slice > unit_info.total; channel_slice = unit_info.total; end
                for i = 1 : ceil(unit_info.total / channel_slice)

                    channel_idx = [i*channel_slice - channel_slice + 1, i*channel_slice];
                    spktimes = all_spktimes(all_spkids >= channel_idx(1) & all_spkids < channel_idx(2));
                    spkids = all_spkids(all_spkids >= channel_idx(1) & all_spkids < channel_idx(2));

                    conv_data = zeros(channel_slice, ceil(max(all_spktimes(:)) * 1000)+1000, 'logical');
                    ind = sub2ind(size(conv_data), spkids - (channel_idx(1)-1), ceil(spktimes * 1000));
                    conv_data(ind)   = 1;

                    bin  = zeros(channel_slice, lfp_data_length, tt, 'logical');
                    for j = 1:tt
                        bin(:,:,j)  = [conv_data(:, onv_1(j):onv_2(j)) conv_data(:, offv_1(j) : offv_2(j))];
                    end

                    lfp.bin(channel_idx(1):channel_idx(2),1:lfp_data_length,1:tt) = bin; clear bin

                    conv_data = spks_conv(single(conv_data), spks_kernel('psp')) .* 1000;

                    conv = zeros(channel_slice, lfp_data_length, ss.total_trials, 'single');
                    for j = 1:tt
                        conv(:,:,j)  =  [conv_data(:, onv_1(j):onv_2(j)) conv_data(:, offv_1(j) : offv_2(j))];
                    end

                    lfp.conv(channel_idx(1):channel_idx(2),1:lfp_data_length,1:tt) = conv; clear conv

                end


        end


    case 'structure'

        lfp.fs = fs; % at or below 1000
        lfp.pre_dur = pre_dur;
        lfp.on_dur = on_dur;
        lfp.off_dur = off_dur;

        lfp.conv                               = nan(unit_info.total, ...
            ceil(lfp.fs*(lfp.pre_dur+lfp.on_dur+lfp.off_dur)), ...
            ss.total_trials);
        for j = 1 : unit_info.total
            conv_data                               = zeros(1, ceil(max(unit_info.spk_times(:)) * 1000)+1000);
            conv_data(1, ceil(unit_info.spk_times(unit_info.spk_unit == j) * 1000))   = 1;
            conv_data                               = single(conv_data);
            conv_data                               = spks_conv(conv_data, spks_kernel('psp')) .* 1000;
            for i = 1 : ss.total_trials
                lfp.cnv(j,:,i)                     = [conv_data(:, ceil((ss.on(i)-lfp.pre_dur)*1000) : ceil((ss.on(i)+lfp.on_dur)*1000)), ...
                    conv_data(:, ceil(ss.off(i)*1000) : ceil((ss.off(i)+lfp.off_dur)*1000))];
            end
            clear conv_data
        end
end
end